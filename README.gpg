MailCrypt for the Gnu Privacy Guard (GPG)
 -Brian Warner <warner@lothar.com>

The GPG support in mailcrypt is at an alpha level and is at least ready for
adventurous users to try out. There are a number of known problems, listed
below. Please send any and all comments, bug reports, patches, enhancements,
etc, to me at <warner@lothar.com>.

First off, what is GPG? GnuPG (formerly known as "g10") is a GPL'ed
replacement for PGP that implements the OpenPGP standard that is slowly making
its way through the IETF OpenPGP working group (it may well be a Proposed
Standard by now.. check your local RFC mirror). It does not implement any
algorithms that cannot be provided under the GPL; that means no RSA
(patented/licensed) or IDEA, so in general it does not interoperate with pgp
2.6 . However it should work with pgp 5.0, pgp 6.0 (theoretically), and of
course itself, and it has a shared-object-loading plugin mechanism whereby new
algorithms can be loaded, so of all the pgpgpgish programs out there it has
the best chance of being compatible. GPG is being developed entirely outside
the USA because of that silly ITAR nonsense.

The GPG home page is at <http://www.d.shuttle.de/isil/crypt/gnupg.html>. The
mailcrypt support for it (contained mostly in mc-gpg.el) was written against
GPG versions 0.3.4 through 0.4.0, though of course later versions should work
too.

KNOWN PROBLEMS:

 key fetching:

  There is no key fetching. I don't know of any GPG keyservers yet. When some
  become available, I'll add support for them. If you try to verify the
  signature on a message when you don't have the signator's key, the code will
  offer to fetch the key for you. If you answer "yes, please fetch that key",
  you'll just get an error message.

 encryption:

  In general, you must have keys for all of your recipients and you must have
  valid trust paths to all of your recipients (see the original pgp
  documentation for a description of the "web of trust"). If you are missing
  one of the keys you will get an error message. UNTRUSTED KEYS ARE MUCH MORE
  SERIOUS: IF THERE IS AT LEAST ONE TRUSTED RECIPIENT, THE UNTRUSTED ONES WILL
  BE SILENTLY IGNORED (if you have mc-encrypt-for-me turned on, there will
  always be at least one trusted recipient), and you'll have a message that
  cannot be decrypted by all the folks you sent it to. Hopefully this will be
  fixed in a later release. If you encrypt to a single untrusted key, you will
  get an error message. Ideally you should just get a warning and the option
  of using the untrusted key anyway (and in fact GPG does this when run by
  hand, just not from the --batch mode used by mailcrypt). Again, this is a
  serious bug (probably the most serious) and fixing it is a goal for a later
  release.

   (as a workaround, try this: create a dummy key. Sign everybody's key with
    that dummy key. Now you've got a trust path. Don't forget to run
    'gpgm --check-trustdb' afterwards to recompute the trust values. Don't
    give out copies of those signed keys, they'll have a worthless dummy
    signature on them. Note that if the web of trust is dense then you don't
    have to sign everybody's key, just the ones that let you trust everybody
    else transitively. But because of the silent-ignore problem, it might be
    safer to just sign them all)

  the --throw-keyid encryption option is not yet supported (a.k.a. "stealth
  mode", where the recipients' keyids are not included in the message, and the
  potential receiver must simply try all of their secret keys to see if any of
  them works).

WRAPPER SCRIPT

  gpg versus "--passphrase-fd 0":

   gpg has an unimplemented routine that would allow a --batch mode program to
   securely send in the passphrase via stdin. This is the same mechanism used
   by pgp2.6 and pgp5.0 . mc-gpg.el is all set to use this hook.  However,
   because the routine is currently unimplemented. we need an external wrapper
   program to take the passphrase from stdin and send it to the real GPG
   through a different filehandle. (emacs does not give you a way to write to
   other filehandles in a child process). gpgwrap.pl is this wrapper. Modify
   it to point to wherever you've installed gpg. Install it somewhere on your
   path (or change mc-gpg-path in mc-gpg.el to point to it).  You can run the
   wrapper exactly like you would GPG itself: unless you pass in
   "--passphrase-fd 0" it simply exec's the real GPG right away, so if you
   wanted to you could install it as gpg and the real GPG as gpg.real or
   something similar.  You'll need perl5 to use the wrapper. If you have a
   newer version of GPG that has implemented the --passphrase-fd 0 case, then
   you can get rid of the wrapper and set mc-gpg-path to point directly at
   GPG. You can also ignore the wrapper if you never need to send a passphrase
   in to gpg, but this would prevent you from signing or decrypting any
   messages.

SMALLER PROBLEMS:

 key names are passed through the shell enclosed in ""s. If the names have any
 quotes in them or seriously weird characters ("!" comes to mind) then the
 shell may have problems. I think the GPG key-generation process may restrict
 the key names to something reasonable, but other programs (pgp5.0?) might
 not.

 there is some debugging code left around. Some temporary buffers may get
 created but not deleted (names generally start with " *mailcrypt"). Some
 temporary files (/tmp/mailcrypt-gpg-*) may get left around.

 mc-gpg.el depends upon /bin/sh to run GPG while redirecting several file
 descriptors to temp files (to collect three different output streams). If you
 don't have /bin/sh, it probably won't work.

 I probably don't have enough (save-excursion ) and (unwind-protect ) clauses.
 If you run into an error halfway through an operation, or if you hit C-g and
 abort an operation, you might not be put back in the buffer you started with.
 Just find your original buffer and hit "undo" if necessary. All mailcrypt
 operations can be undone with "undo".

 I've tested a number of cases, but I haven't been able to create test
 messages for some of them, like signed messages that have been tampered with.
 (clearsigned messages with tampering are caught, but I don't know how to
 modify an unclear signed message to invalidate the signature without also
 damaging the CRC added by the ascii armor). If you know how to create such a
 message, please send it to me so I can test those cases too. The same goes
 for the (probably much more difficult) case of encrypted+signed messages that
 decrypt OK but have bad signatures.

REALLY TINY PROBLEMS:

 mc-gpg-comment works fine, I just disabled it to let GPG insert it's own
 advertisement showing URL of the GPG home page.

 mc-gpg-alternate-keyring might work. It should probably be split up so you
 can add public and private rings separately.

 mailcrypt is designed to handle multiple encryption schemes. Decryption is
 supposed to work by trying each one in order, stopping after one of them
 succeeds. mc-gpg.el will have two problems with this. One is that my code
 will probably error out upon failure instead of returning a failure and
 allowing the top-level scheme loop to try another scheme. The second is that
 pgp2.6, pgp5.0, and gpg all use the same packet format, so it isn't generally
 obvious what scheme should be used (unless you look for a version or comment
 header in the armored message). This is complicated by the fact that they can
 use each other's keys, to a certain extent. I don't have a good answer for
 this yet. One is to keep all your keyrings separate. One is to figure out how
 to use GPG for everything and merge all your keyrings into your GPG
 keyring. If you manage that one, let me know about it.

WILD ENHANCEMENT IDEAS:

 it would be cool to incorporate some trust status reporting into this code.
 you give it a keyid and it shows you the best trust path to that key.

 key management from within emacs: sign keys, edit trust.

 set algorithm preferences or extra options (--rfc1991) by recipient ID. this
 might help pgp compatibility

 tab-completion on keyids, using --list-keys or --list-secret-keys.

 rfc2015 operation (MIME multipart/encrypted). see SEMI for the pgp version.

 create a detached signature from the current buffer



Share and Enjoy,
 -Brian Warner
 <warner@lothar.com>

